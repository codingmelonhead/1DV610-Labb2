# Reflection

## Chapter 2

|Name and description| Reflection and rules according to Clean Code|
|-----|-----|
|ArrayUtils Class name for main class | ArrayUtils is not technically a **noun or noun phrase name**. I could change the name to ArrayHelper or ArrayHandler to follow this rule better, however utils is a widely recognized naming convention for a collection of utility methods which is true in this case and therefore i will keep it as is.|
|value Argument to the method findObjectValue| **Don’t Add Gratuitous Context.** This could have been named targetValue or something similar to be even more specific what the argument is for. I instead choose to go with the shorter name value because its context is already provided in the method name and the rule states *”Shorter names are generally better than longer ones, so long as they are clear. Add no more context to a name than is necessary.”*|
|valueGroup Variable in the groupByObjectValue | **Avoid Disinformation.** This name should be changed, and will be in the future. The variable is used to store groups of objects that have the same value in a key/value pair. At the very least it should be renamed to valueGroups, when also considering **Use Intention-Revealing Names** a better name would probably be storeValueGroups or even storeKeyValuePairObjectsInValueGroups. The last suggestion may infringe on **Dont Add Gratuitous Context** which I personally like to pay attention to, and the change will probably be storeValueGroups.|
|findObjectValue Method in ArrayUtils| **Dont Pun.** This method takes a value as an argument and returns an array with objects that contains that value. Since this method technically groups objects with this specific value and there are other methods that also groups objects and their names starts with “group” i was first tempted to name the method groupObjectValue for consistency. However the semantics of these methods are different and therefore should be separated naming-wise.|
|allKeys Variable in groupByObjectKeys| **Avoid Disinformation.** I used allKeys as a variable name for all keys in the current object. I would say this is borderline disinformation because it can be interpreted as all the keys in the array which is not the case. In future versions of this library it will be changed to keys since context is already provided earlier in the method.|

### Reflection Chapter 2
I would like to start with my own summarizing and takeaways from chapter two. I think the chapter can be stripped down to 3 keywords: descriptive, short and consistent, slightly prioritized in that order. The rules that the author supplies are mostly tools to achieve this because it's usually not an easy thing to do. Most of the chapter is about giving rules to make a name descriptive but Add Meaningful Context, Don't Add Gratuitous Context and Make Meaningful Distinctions is, according to me, mostly about keeping the name short but yet descriptive. When you use descriptive names that avoid noise words in all parts of your code they give context to each other and don't need to be especially long to still describe what they do. All in all i would say that the authors perspective aligns with what i strive for even though it's not always what i end up with (as shown in the table).

## Chapter 3

|Method name and link | Amount of lines | Reflection |
|-----|--|-----|
|[getDetailedTypes](../src/arrayInformation.js)|46| **Do one thing.** This method breaks this rule, both when it comes to the error handling and what the author thinks of the if statements. The error handling will be changed in a future version. I will however not be breaking out the if statements in a separate method as the author wants, instead i will use a switch statement and keep that in one single method, even though the author thinks that should be broken out of the method i think it will only reduce readability. The method will still, arguably, follow the Do one thing rule. It also breaks the **DRY-principle** because of the error handling. The method has one argument (monadic), array, and follows the rules since technically it asks a question about the array and returns the answer.|
|[groupByMatchingKeyValue](../src/arrayOrganizer.js)|28| **Do one thing.** As stated above error handling needs to be broken out for two reasons (Do one thing and DRY). The method has one argument (monadic) and follows the rules for **Common Monadic Forms.** The method performs a transformation, returns a new array and does not modify the original array. This aligns with the rule **Have No Side Effects.** (Read reflection on groupByObjectKeys for a different take on whether this method truly is monadic)|
|[groupByObjectValues](../src/arrayOrganizer.js)|27| **Do one thing.** Except for the error handling it does follow this principle. **DRY-principle.** This method (and groupByMatchingKeyValue) could be broken down and use a private helper method that does the for loops since they are very similar. The method takes one argument and is monadic. (Read reflection on groupByObject keys for a different perspective if this method truly is monadic).|
|[groupByObjectKeys](../src/arrayOrganizer.js)|22| This method takes one argument and is monadic but can actually be considered to be nidalic. Just as groupByMatchingKeyValue and groupByObjectValues this takes an array as an argument, but they are called on through a class called ArrayUtils. When creating an instance of ArrayUtils you pass the array as an argument and these methods use that array so when using the methods the user dont supply another array.|
|[findObjectValue](../src/arrayFinder.js)|20|**Do one thing.** As in the other methods, error handling should be handled in its own method. Otherwise it follows the rules. It could be considered to be dyadic or monadic. I will be considering this method to be monadic due to how the user will be using it. It does follow the rules for a **monadic method**, it answers what objects with a specific value exist in the array argument.|

### Reflection Chapter 3
I don't generally agree with how small the author thinks the functions should be, I think that making a function as small as possible for the sake of keeping it small is taking away readability with no real upside. You could make the argument that with good method names that it will solve that problem, but it will still make it much harder to actually understand how the method works. With that being said I agree with the mindset about trying to keep the methods small, that includes the DRY-principle and Error Handling Is One Thing, just not to the extreme as described, hiding switch statements and trying to make every method a one-liner. I made the mistake of not breaking out my error handling but that will be adjusted in future versions.

### General Reflection on Clean Code
I have noticed that I tend to use long and descriptive names in my journey of coding, which almost naturally becomes intention revealing. The problem I have with naming classes, methods and variables is to avoid disinformation and have meaningful context throughout a project. By having a meaningful context you can still have very descriptive names but avoid making a novel to whoever reads my code. It's also easy to slip up with consistency, without thinking I have (not in this project) used both fetch and get to gather data in a project, which is by itself correct, just not together. During this project I think I have done a relatively good job with naming and there are only small adjustments needing to be made to adhere to the rules in chapter 2 of Clean Code.

In this project I have been really focusing on using as little argument as I can but still give the library somewhat diversity when it comes to functionality and being user friendly. I experimented with extending the Array.prototype in JavaScript to make almost all methods niladic but ended up using a class that gathered the methods instead. By doing it that way I avoid any unexpected problems that may arise either now or in the future when the library gets updated with the built in Array.prototype. It is still arguably almost completely niladic except for UtilArrays and findObjectValue that are both monadic. As mentioned before there is still some refactoring left to do in my project such as adhere to the DRY-principle and make my methods “Do One Thing” since the error handling is currently inside each method. 
